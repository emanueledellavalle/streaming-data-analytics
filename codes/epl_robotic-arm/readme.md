# An example of an Exam question solved in EPL

## Introductions

Suppose you want to monitor a group of robots used for picking and placing goods in an Industry 4.0 storehouse with a stream processing engine.
Each robotic arm sends events reporting its status: 

* ready to pick a good, 
* good grasped, 
* moving a good, 
* placing a good, 
* moving without any goods. 

Several Force-Sensing Resistors measure the stress levels of the robotic arm. The robot is safely operating if the stress level is between 0 and 6. A controller should raise a warning if it is between 7 and 8. If it is above 9, a controller should stop the robot.

## Questions & answers

### E1

Propose how to model the streaming data generated by the robotic arms.

#### Some thinking

There are two forces: the **reality** and the **pragmatism**

The **reality** pushes for the most detailed model. Notably, the text above may imply that the Force-Sensing Resistors are independent sensors sending their own events separately from the arms. So one may be tempted to propose the following modeling.

```
create schema RoboticArm(id string, status string); 
create schema ForceSensingResistors(idArm string, stressLvl int)
```

The **pragmatism**, on the contrary, pushes for the minimum model that allows the continuous process of the data so to satisfy the needs presented in the following point (from E2 to E5). If you read them, you may understand that they require a much simpler model:

```
create schema RoboticArm( id string, status string, stressLevel int );
```

The rest of the proposed solution follows the pragmatic approach.

#### A best practice

A best practice that I recommend is always to write down a portion of the stream modeled according to your design choice.

For instance:

```
RoboticArm={id="1", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="goodGrasped", stressLevel=1} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="movingGood", stressLevel=7} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="goodGrasped", stressLevel=5} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="movingGood", stressLevel=9} 
t=t.plus(5 seconds) 
RoboticArm={id="2", status="placingGood", stressLevel=3} 
RoboticArm={id="1", status="placingGood", stressLevel=3} 
t=t.plus(4 seconds) 
RoboticArm={id="1", status="moving", stressLevel=2} 
RoboticArm={id="2", status="moving", stressLevel=1} 
t=t.plus(3 seconds) 
RoboticArm={id="1", status="ready", stressLevel=0} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds)
```

Another best practice is always to state your assumptions:

* the arm sends an event only when it changes its status
* the status can only appear in the order listed in the text above
* if the arm stops due to a fault, it does not send any event
* the arm restarts after a fault, it is always in the status ready
* the stress level in each event is the maximum the arm experienced between the reported status and the previous one

### E2 

Write a continuous query that emits the maximum stress for each arm.

#### Solution

```
@Name("E2") 
SELECT id, max(stressLevel) 
FROM RoboticArm 
GROUP BY id;
```

### E3 

A continuous query that emits the average stress level between a pick (status==goodGrasped) and a place (status==placingGood). 

HINT: Sometimes you cannot compute an average using the aggregate operator `avg`

#### Solution

```
@Name("E3") 
SELECT a.id, (a.stressLevel + b.stressLevel + c.stressLevel) / 3
FROM pattern [ 
	every 	a=RoboticArm(status="goodGrasped") -> 
		  	b=RoboticArm(id = a.id, status="movingGood") ->
		  	c=RoboticArm(id = a.id, status="placingGood")  ];
```

### E4

A continuous query that returns the robotic arms that, 

* in less than 10 seconds,
* picked a good while safely operating,
* moved it while the controller was raising a warning, and
* placed it while safely operating again.

#### Solution

```
@Name("E4") 
insert into warning
SELECT a.id 
FROM pattern [ 
	every	a=RoboticArm(status="goodGrasped", stressLevel < 7) ->
			(
				b=RoboticArm(id = a.id, status="movingGood", stressLevel > 6 and stressLevel < 9) ->
				c=RoboticArm(id = a.id, status="placingGood", stressLevel < 7) 
			)
			where timer:within(10 seconds)
		] ;
```

### E5

A continuous query that monitors the results of the previous one (i.e., E4) and counts how many times each robotic arm is present in the stream over a window of 10 seconds, updating the counting every 2 seconds.

#### Solution

```
@Name("E5") 
select arm, count(*)
from warning.win:time(10 sec)
group by arm
output last every 2 sec;
```

## Bonus content

### relaxing assumptions

#### What if the arm does not send an event only when it changes the status?

for instance, it may report moving goods multiple times, such as in 

```
RoboticArm={id="1", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="goodGrasped", stressLevel=1} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="movingGood", stressLevel=7} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="movingGood", stressLevel=7} 
RoboticArm={id="2", status="goodGrasped", stressLevel=5} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="movingGood", stressLevel=9} 
t=t.plus(5 seconds) 
RoboticArm={id="2", status="placingGood", stressLevel=3} 
RoboticArm={id="1", status="placingGood", stressLevel=3} 
t=t.plus(4 seconds) 
RoboticArm={id="1", status="moving", stressLevel=2} 
RoboticArm={id="2", status="moving", stressLevel=1} 
t=t.plus(3 seconds) 
RoboticArm={id="1", status="ready", stressLevel=0} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds)
```

Is the E4 solution still valid? Shall we add a new `every` clause somewhere?

Adding `every` in front of `b=RoboticArm(id = a.id, status="movingGood", stressLevel > 6 and stressLevel < 9)` makes a difference

```
@Name("E4.every") 
insert into warning
SELECT a.id 
FROM pattern [ 
	every	a=RoboticArm(status="goodGrasped", stressLevel < 7) -> 
			(  
				every b=RoboticArm(id = a.id, status="movingGood", stressLevel > 6 and stressLevel < 9) ->
				c=RoboticArm(id = a.id, status="placingGood", stressLevel < 7) 
			)
			where timer:within(10 seconds)
		] ;
```

#### What if the control system sends a stop event when an arm has a fault

extra event type

```
create schema Stop( id string);
```

data that contains it making the alternative assumption that arms restarts after a fault in the status they were before the fault. 

```
RoboticArm={id="1", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="goodGrasped", stressLevel=1} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="movingGood", stressLevel=7} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="goodGrasped", stressLevel=5} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="movingGood", stressLevel=9} 
t=t.plus(2 seconds) 
Stop={id="1"}
t=t.plus(3 seconds) 
RoboticArm={id="2", status="placingGood", stressLevel=3}  
t=t.plus(4 seconds) 
RoboticArm={id="2", status="moving", stressLevel=1} 
t=t.plus(3 seconds) 
RoboticArm={id="1", status="ready", stressLevel=0} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds)
```

In that case, E4 may be updated as follows to **avoid creating a warning** if the arm stops while moving.

```
@Name("E4.andnot") 
insert into warning
SELECT a.id 
FROM pattern [ 
	every	a=RoboticArm(status="goodGrasped", stressLevel < 7) -> 
			(  every
				b=RoboticArm(id = a.id, status="movingGood", stressLevel > 6 and stressLevel < 9) ->
				c=RoboticArm(id = a.id, status="placingGood", stressLevel < 7) and not Stop(id = a.id)
			)
			where timer:within(10 seconds)
		] ;
```

NOTE: if you remove the Stop event, `E4.andnot` matches once. With the Stop event, it does not match.

### understanding parenthesis and `where timer:within`

```
create schema A (
n int
);

create schema B (
n int
);

create schema C (
n int
);

@name("experiment.0")
select a.n, b.n, c.n
from pattern [
a=A -> b=B -> c=C where timer:within(1 sec)
];

@name("experiment.1")
select a.n, b.n, c.n
from pattern [
a=A -> b=B -> c=C where timer:within(2 sec)
];

@name("experiment.2")
select a.n, b.n, c.n
from pattern [
a=A -> (b=B -> c=C) where timer:within(2 sec)
];

@name("experiment.3")
select a.n, b.n, c.n
from pattern [
a=A -> (b=B -> c=C) where timer:within(3 sec)
];
```

using

```
A={n=1} 
t=t.plus(1 seconds) 
B={n=1} 
t=t.plus(1 seconds) 
C={n=1}
```

the answers are

```
At: 2001-01-01 08:00:02.000

    Statement: experiment.1
        Insert
            experiment.1-output={a.n=1, b.n=1, c.n=1}
    Statement: experiment.3
        Insert
            experiment.3-output={a.n=1, b.n=1, c.n=1}
```

NOTE: Only `experiment.1` and `experiment.3` match.

